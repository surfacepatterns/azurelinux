From 359ba67345bc299a5378b81e0ba54fe4b53291b5 Mon Sep 17 00:00:00 2001
From: Vince Perri <5596945+vinceaperri@users.noreply.github.com>
Date: Wed, 24 Jul 2024 17:08:45 +0000
Subject: [PATCH] test patch

---
 src/tss2-esys/esys_crypto_ossl.c | 136 -------------------------------
 1 file changed, 136 deletions(-)

diff --git a/src/tss2-esys/esys_crypto_ossl.c b/src/tss2-esys/esys_crypto_ossl.c
index 89d312f..520d8f9 100644
--- a/src/tss2-esys/esys_crypto_ossl.c
+++ b/src/tss2-esys/esys_crypto_ossl.c
@@ -12,13 +12,7 @@
 #include <openssl/evp.h>
 #include <openssl/rsa.h>
 #include <openssl/ec.h>
-#if OPENSSL_VERSION_NUMBER < 0x30000000L
 #include <openssl/aes.h>
-#else
-#include <openssl/core_names.h>
-#include <openssl/params.h>
-#include <openssl/param_build.h>
-#endif
 #include <openssl/engine.h>
 #include <stdio.h>
 
@@ -33,21 +27,12 @@
 #include "util/log.h"
 #include "util/aux_util.h"
 
-#if OPENSSL_VERSION_NUMBER >= 0x10101000L
 #define EC_POINT_set_affine_coordinates_tss(group, tpm_pub_key, bn_x, bn_y, dmy) \
         EC_POINT_set_affine_coordinates(group, tpm_pub_key, bn_x, bn_y, dmy)
 
 #define EC_POINT_get_affine_coordinates_tss(group, tpm_pub_key, bn_x, bn_y, dmy) \
         EC_POINT_get_affine_coordinates(group, tpm_pub_key, bn_x, bn_y, dmy)
 
-#else
-#define EC_POINT_set_affine_coordinates_tss(group, tpm_pub_key, bn_x, bn_y, dmy) \
-        EC_POINT_set_affine_coordinates_GFp(group, tpm_pub_key, bn_x, bn_y, dmy)
-
-#define EC_POINT_get_affine_coordinates_tss(group, tpm_pub_key, bn_x, bn_y, dmy) \
-        EC_POINT_get_affine_coordinates_GFp(group, tpm_pub_key, bn_x, bn_y, dmy)
-#endif /* OPENSSL_VERSION_NUMBER >= 0x10101000L */
-
 static int
 iesys_bn2binpad(const BIGNUM *bn, unsigned char *bin, int bin_length)
 {
@@ -66,12 +51,7 @@ typedef struct ESYS_CRYPTO_CONTEXT_BLOB {
     } type; /**< The type of context to hold; hash or hmac */
     union {
         struct {
-#if OPENSSL_VERSION_NUMBER < 0x30000000L
             const EVP_MD *ossl_hash_alg;
-#else
-            OSSL_LIB_CTX *ossl_libctx;
-            EVP_MD *ossl_hash_alg;
-#endif
             EVP_MD_CTX  *ossl_context;
             size_t hash_len;
         } hash; /**< the state variables for a HASH or HMAC context */
@@ -85,15 +65,6 @@ iesys_cryptossl_context_new() {
     if (!(ctx = calloc(1, sizeof(IESYS_CRYPTOSSL_CONTEXT))))
         return NULL;
 
-#if OPENSSL_VERSION_NUMBER >= 0x30000000L
-    /* The TPM2 provider may be loaded in the global library context.
-     * As we don't want the TPM to be called for these operations, we have
-     * to initialize own library context with the default provider. */
-    if (!(ctx->hash.ossl_libctx = OSSL_LIB_CTX_new())) {
-        SAFE_FREE(ctx);
-        return NULL;
-    }
-#endif
     return ctx;
 }
 
@@ -103,14 +74,9 @@ iesys_cryptossl_context_free(IESYS_CRYPTOSSL_CONTEXT *ctx) {
         return;
 
     EVP_MD_CTX_free(ctx->hash.ossl_context);
-#if OPENSSL_VERSION_NUMBER >= 0x30000000L
-    EVP_MD_free(ctx->hash.ossl_hash_alg);
-    OSSL_LIB_CTX_free(ctx->hash.ossl_libctx);
-#endif
     SAFE_FREE(ctx);
 }
 
-#if OPENSSL_VERSION_NUMBER < 0x30000000L
 static const EVP_MD *
 get_ossl_hash_md(TPM2_ALG_ID hashAlg)
 {
@@ -131,37 +97,10 @@ get_ossl_hash_md(TPM2_ALG_ID hashAlg)
         return NULL;
     }
 }
-#else
-static const char *
-get_ossl_hash_md(TPM2_ALG_ID hashAlg)
-{
-    switch (hashAlg) {
-    case TPM2_ALG_SHA1:
-        return "SHA1";
-    case TPM2_ALG_SHA256:
-        return "SHA256";
-    case TPM2_ALG_SHA384:
-        return "SHA384";
-    case TPM2_ALG_SHA512:
-        return "SHA512";
-    case TPM2_ALG_SM3_256:
-        return "SM3";
-    default:
-        return NULL;
-    }
-}
-#endif
 
 static int
 iesys_cryptossl_context_set_hash_md(IESYS_CRYPTOSSL_CONTEXT *ctx, TPM2_ALG_ID hashAlg) {
-#if OPENSSL_VERSION_NUMBER < 0x30000000L
     ctx->hash.ossl_hash_alg = get_ossl_hash_md(hashAlg);
-#else
-    const char *alg_name =  get_ossl_hash_md(hashAlg);
-    if (!alg_name)
-        return 0;
-    ctx->hash.ossl_hash_alg = EVP_MD_fetch(ctx->hash.ossl_libctx, alg_name, NULL);
-#endif
     if (!ctx->hash.ossl_hash_alg)
         return 0;
 
@@ -392,12 +331,8 @@ iesys_cryptossl_hmac_start(ESYS_CRYPTO_CONTEXT_BLOB ** context,
                    "Error EVP_MD_CTX_create", cleanup);
     }
 
-#if OPENSSL_VERSION_NUMBER < 0x10101000L
-    if (!(hkey = EVP_PKEY_new_mac_key(EVP_PKEY_HMAC, NULL, key, size))) {
-#else
     /* this is preferred, but available since OpenSSL 1.1.1 only */
     if (!(hkey = EVP_PKEY_new_raw_private_key(EVP_PKEY_HMAC, NULL, key, size))) {
-#endif
         goto_error(r, TSS2_ESYS_RC_GENERAL_FAILURE,
                    "Failed to create HMAC key", cleanup);
     }
@@ -556,14 +491,8 @@ iesys_cryptossl_random2b(
     UNUSED(userdata);
 
     int rc;
-#if OPENSSL_VERSION_NUMBER < 0x30000000L
     const RAND_METHOD *rand_save = RAND_get_rand_method();
     RAND_set_rand_method(RAND_OpenSSL());
-#else
-    OSSL_LIB_CTX *libctx = OSSL_LIB_CTX_new();
-    if (!libctx)
-        return TSS2_ESYS_RC_MEMORY;
-#endif
 
     if (num_bytes == 0) {
         nonce->size = sizeof(nonce->buffer);
@@ -571,13 +500,8 @@ iesys_cryptossl_random2b(
         nonce->size = num_bytes;
     }
 
-#if OPENSSL_VERSION_NUMBER < 0x30000000L
     rc = RAND_bytes(&nonce->buffer[0], nonce->size);
     RAND_set_rand_method(rand_save);
-#else
-    rc = RAND_bytes_ex(libctx, &nonce->buffer[0], nonce->size, 0);
-    OSSL_LIB_CTX_free(libctx);
-#endif
     if (rc != 1)
         return_error(TSS2_ESYS_RC_GENERAL_FAILURE,
                      "Failure in random number generator.");
@@ -611,18 +535,11 @@ iesys_cryptossl_pk_encrypt(TPM2B_PUBLIC * pub_tpm_key,
 {
     UNUSED(userdata);
 
-#if OPENSSL_VERSION_NUMBER < 0x30000000L
     RSA *rsa_key = NULL;
     const EVP_MD * hashAlg = NULL;
     const RAND_METHOD *rand_save = RAND_get_rand_method();
 
     RAND_set_rand_method(RAND_OpenSSL());
-#else
-    OSSL_LIB_CTX *libctx = NULL;
-    EVP_MD * hashAlg = NULL;
-    OSSL_PARAM *params = NULL;
-    OSSL_PARAM_BLD *build = NULL;
-#endif
 
     TSS2_RC r = TSS2_RC_SUCCESS;
     EVP_PKEY *evp_rsa_key = NULL;
@@ -631,17 +548,8 @@ iesys_cryptossl_pk_encrypt(TPM2B_PUBLIC * pub_tpm_key,
     int padding;
     char *label_copy = NULL;
 
-#if OPENSSL_VERSION_NUMBER < 0x30000000L
     if (!(hashAlg = get_ossl_hash_md(pub_tpm_key->publicArea.nameAlg))) {
         RAND_set_rand_method(rand_save);
-#else
-    if (!(libctx = OSSL_LIB_CTX_new()))
-        return TSS2_ESYS_RC_MEMORY;
-
-    if (!(hashAlg = EVP_MD_fetch(libctx,
-            get_ossl_hash_md(pub_tpm_key->publicArea.nameAlg), NULL))) {
-        OSSL_LIB_CTX_free(libctx);
-#endif
         LOG_ERROR("Unsupported hash algorithm (%"PRIu16")",
                   pub_tpm_key->publicArea.nameAlg);
         return TSS2_ESYS_RC_NOT_IMPLEMENTED;
@@ -674,7 +582,6 @@ iesys_cryptossl_pk_encrypt(TPM2B_PUBLIC * pub_tpm_key,
                    "Could not create rsa n.", cleanup);
     }
 
-#if OPENSSL_VERSION_NUMBER < 0x30000000L
     if (!(rsa_key = RSA_new())) {
         goto_error(r, TSS2_ESYS_RC_MEMORY,
                    "Could not allocate RSA key", cleanup);
@@ -708,22 +615,6 @@ iesys_cryptossl_pk_encrypt(TPM2B_PUBLIC * pub_tpm_key,
     }
     /* ownership got transferred */
     rsa_key = NULL;
-#else /* OPENSSL_VERSION_NUMBER < 0x30000000L */
-    if ((build = OSSL_PARAM_BLD_new()) == NULL
-            || !OSSL_PARAM_BLD_push_BN(build, OSSL_PKEY_PARAM_RSA_N, n)
-            || !OSSL_PARAM_BLD_push_uint32(build, OSSL_PKEY_PARAM_RSA_E, exp)
-            || (params = OSSL_PARAM_BLD_to_param(build)) == NULL) {
-        goto_error(r, TSS2_ESYS_RC_GENERAL_FAILURE, "Could not create rsa parameters.",
-                   cleanup);
-    }
-
-    if ((genctx = EVP_PKEY_CTX_new_from_name(libctx, "RSA", NULL)) == NULL
-            || EVP_PKEY_fromdata_init(genctx) <= 0
-            || EVP_PKEY_fromdata(genctx, &evp_rsa_key, EVP_PKEY_PUBLIC_KEY, params) <= 0) {
-        goto_error(r, TSS2_ESYS_RC_GENERAL_FAILURE, "Could not create rsa key.",
-                   cleanup);
-    }
-#endif /* OPENSSL_VERSION_NUMBER < 0x30000000L */
 
     if (!(ctx = EVP_PKEY_CTX_new(evp_rsa_key, NULL))) {
         goto_error(r, TSS2_ESYS_RC_GENERAL_FAILURE,
@@ -782,15 +673,8 @@ iesys_cryptossl_pk_encrypt(TPM2B_PUBLIC * pub_tpm_key,
     OSSL_FREE(evp_rsa_key, EVP_PKEY);
     OSSL_FREE(bne, BN);
     OSSL_FREE(n, BN);
-#if OPENSSL_VERSION_NUMBER < 0x30000000L
     OSSL_FREE(rsa_key, RSA);
     RAND_set_rand_method(rand_save);
-#else
-    OSSL_FREE(params, OSSL_PARAM);
-    OSSL_FREE(build, OSSL_PARAM_BLD);
-    OSSL_FREE(hashAlg, EVP_MD);
-    OSSL_FREE(libctx, OSSL_LIB_CTX);
-#endif
     return r;
 }
 
@@ -883,12 +767,8 @@ iesys_cryptossl_get_ecdh_point(TPM2B_PUBLIC *key,
     EC_GROUP *group = NULL;               /* Group defines the used curve */
     EVP_PKEY_CTX *ctx = NULL;
     EVP_PKEY *eph_pkey = NULL;
-#if OPENSSL_VERSION_NUMBER < 0x30000000L
     const EC_POINT *eph_pub_key = NULL;   /* Public part of ephemeral key */
     const BIGNUM *eph_priv_key = NULL;
-#else
-    BIGNUM *eph_priv_key = NULL;
-#endif
     EC_POINT *tpm_pub_key = NULL;         /* Public part of TPM key */
     EC_POINT *mul_eph_tpm = NULL;
     BIGNUM *bn_x = NULL;
@@ -919,12 +799,10 @@ iesys_cryptossl_get_ecdh_point(TPM2B_PUBLIC *key,
         curveId = NID_secp521r1;
         key_size = 66;
         break;
-#if OPENSSL_VERSION_NUMBER >= 0x10101000L
     case TPM2_ECC_SM2_P256:
         curveId = NID_sm2;
         key_size = 32;
         break;
-#endif
     default:
         return_error(TSS2_ESYS_RC_NOT_IMPLEMENTED,
                      "ECC curve not implemented.");
@@ -947,7 +825,6 @@ iesys_cryptossl_get_ecdh_point(TPM2B_PUBLIC *key,
         goto_error(r, TSS2_ESYS_RC_GENERAL_FAILURE, "Generate ec key", cleanup);
     }
 
-#if OPENSSL_VERSION_NUMBER < 0x30000000L
     EC_KEY *eph_ec_key = EVP_PKEY_get0_EC_KEY(eph_pkey);
 
     if (!(eph_pub_key =  EC_KEY_get0_public_key(eph_ec_key))) {
@@ -974,14 +851,6 @@ iesys_cryptossl_get_ecdh_point(TPM2B_PUBLIC *key,
         goto_error(r, TSS2_ESYS_RC_GENERAL_FAILURE,
                    "Get affine coordinates", cleanup);
     }
-#else
-    if (!EVP_PKEY_get_bn_param(eph_pkey, OSSL_PKEY_PARAM_PRIV_KEY, &eph_priv_key)
-            || !EVP_PKEY_get_bn_param(eph_pkey, OSSL_PKEY_PARAM_EC_PUB_X, &bn_x)
-            || !EVP_PKEY_get_bn_param(eph_pkey, OSSL_PKEY_PARAM_EC_PUB_Y, &bn_y)) {
-        goto_error(r, TSS2_ESYS_RC_GENERAL_FAILURE,
-                   "Get ephemeral key", cleanup);
-    }
-#endif
 
     if (1 != iesys_bn2binpad(bn_x, &Q->x.buffer[0], key_size)) {
         goto_error(r, TSS2_ESYS_RC_GENERAL_FAILURE,
@@ -1037,11 +906,6 @@ iesys_cryptossl_get_ecdh_point(TPM2B_PUBLIC *key,
     OSSL_FREE(group,EC_GROUP);
     OSSL_FREE(ctx, EVP_PKEY_CTX);
     OSSL_FREE(eph_pkey, EVP_PKEY);
-#if OPENSSL_VERSION_NUMBER < 0x30000000L
-    /* Note: free of eph_pub_key already done by free of eph_ec_key */
-#else
-    OSSL_FREE(eph_priv_key, BN);
-#endif
     OSSL_FREE(bn_x, BN);
     OSSL_FREE(bn_y, BN);
     return r;
-- 
2.34.1

